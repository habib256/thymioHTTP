import { mobsya } from './thymio_generated';
/**
 * Each variable has a name an a value
 * When communication with a Thymio 2, variables are always an array of int16.
 * Sending an unique value to a Thymio 2 is equivalent to sending an array of size 1.
 * Sending a value of an expected type will raise an exception.
 */
export declare type Variables = Map<string, any>;
/**
 * Each event has a name an a value
 * When communication with a Thymio 2, event are always an array 0 or more int16.
 * The arity of the event must match [[EventDescription.fixed_size]]
 * Sending a event of an unexpected type or size will raise an exception.
 */
export declare type Events = Map<string, any>;
/**
 * NodeId stores the 128bit UUID of the node
 */
export declare class NodeId {
    private _data;
    constructor(array: Uint8Array);
    /**
     * RFC 4122 compatible GUID - little-endian
     */
    readonly data: Uint8Array;
    /**
     * Return a string representation of the GUID
     * compatible with microsof representation scheme
     *
     * {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
     */
    toString(): string;
}
/** Description of an aseba virtual machine. */
export declare class AsebaVMDescription {
    /**
     * Amount of memory reserved for bytecode on this VM, in bytes
     */
    bytecode_size: number;
    /**
    * Amount of memory reserved for data on this VM, in bytes
    */
    data_size: number;
    /**
    * Size of the stack of the vm, in bytes
    */
    stack_size: number;
    /**
     * List of the persistent, non-shared variables available on this VM
     */
    variables: Array<any>;
    /**
     * List of the persistent, non-shared internal events that this vm can
     * react to. VM events can not be be emitted.
     */
    events: Array<any>;
    /**
    * List of the natives functions available on this VM
    */
    functions: Array<any>;
}
/**
 * Description of a shared event.
 *
 */
export declare class EventDescription {
    /**
     * Name of the event
     *
     * Needs to be a valid Aseba Identifier (start by a letter, no space)
     */
    name: string;
    /**
     * Thymio 2 only supprts events that are fixed-size int16[]
     *
     * fixed_size describes the size, in word, of the event
     */
    fixed_size: number;
    /**
     * Index of the event
     * @internal
     */
    index: number;
}
/**
 * Group and Node share a common base interface.
 */
export interface IBasicNode {
    /**
     * Unique Id of the node
     */
    readonly id: NodeId;
    /**
     * Request the TDM to dispatch modifications of the
     * shared variables and event description for a group
     * or a Thymio to this client.
     *
     * This *must* be called for the following event to be triggered
     *  * [[IGroup.onEventsDescriptionsChanged]]
     *  * [[IGroup.onVariablesChanged]]
     *  * [[INode.onEventsDescriptionsChanged]]
     *  * [[INode.onSharedVariablesChanged]]
     *
     * @param flags bitflag of [[fb.mobsya.WatchableInfo]]
     */
    watchSharedVariablesAndEvents(enable: boolean): Promise<any>;
    /**
     * Send events to a group
     * Each event must be registed on the group (see [[setEventsDescriptions]])
     *
     * When sending events to Thymio 2, the value of each event must be an array of int16 matching [[EventDescription.fixed_size]]
     * @param events events to broadcast
     */
    emitEvents(events: Events): Promise<any>;
    emitEvents(key: string, value: any): Promise<any>;
    emitEvents(key: string): Promise<any>;
}
/**
 * @private
 */
declare class BasicNode implements IBasicNode {
    protected _monitoring_flags: number;
    protected _client: Client;
    protected _id: NodeId;
    constructor(client: Client, id: NodeId);
    readonly id: NodeId;
    watchSharedVariablesAndEvents(enable: boolean): Promise<any>;
    _set_monitoring_flags(flag: any, set: any): Promise<any>;
    emitEvents(map_or_key: string | Events, value?: any): Promise<any>;
}
/**
 * A group represents a list of robots
 * sharing the same persistent state.
 *
 * Group hold the events and shared variables for all robots in the group.
 *
 * Events sent to a group or a robots will be broadcasted to all robots
 * in that group.
 *
 */
export interface IGroup extends IBasicNode {
    /**
     * Shared variables registered on this group
     * @see [[setVariables]]
     */
    readonly variables: Variables;
    /**
     * List of events registered on this group
     */
    readonly eventsDescriptions: EventDescription[];
    /**
    * All nodes registed on this group
    */
    readonly nodes: Node[];
    /**
     * @event
     * Emitted each time the list of registered events changes
     * @see [[watchSharedVariablesAndEvents]]
     */
    onEventsDescriptionsChanged: (events: EventDescription[]) => void;
    /**
     * @event
     * Emitted each time the list of registered variables changes.
     * @see [[watchSharedVariablesAndEvents]]
     */
    onVariablesChanged: (variables: Variables) => void;
    /**
     * Set the shared variables registered on the group.
     *
     * @param variables variables to set. Will erase any previous
     * registered variables.
     *
     * This client must holds a lock on at least one node of this group
     * for the operation to be sucessful
     *
     * @see [[INode.lock]]
     *
     */
    setVariables(variables: Variables): Promise<any>;
    /**
     * Set the events registered on the group.
     *
     * @param events variables to set. Will erase any previously
     * registered events.
     *
     * This client must holds a lock on at least one node of this group
     * for the operation to be sucessful
     *
     * @see [[INode.lock]]
     *
     */
    setEventsDescriptions(events: EventDescription[]): Promise<any>;
}
/**
 * @private
 */
declare class Group extends BasicNode implements IGroup {
    _variables: any;
    _events: any;
    private _on_variables_changed;
    private _on_events_descriptions_changed;
    constructor(client: Client, id: NodeId);
    readonly variables: any;
    setVariables(variables: Variables): Promise<any>;
    readonly eventsDescriptions: any;
    setEventsDescriptions(events: any): Promise<any>;
    readonly nodes: Node[];
    onEventsDescriptionsChanged: (events: EventDescription[]) => void;
    onVariablesChanged: (variables: Map<string, any>) => void;
}
export import NodeStatus = mobsya.fb.NodeStatus;
export import NodeType = mobsya.fb.NodeType;
export import ProgrammingLanguage = mobsya.fb.ProgrammingLanguage;
export import VMExecutionState = mobsya.fb.VMExecutionState;
/**
 * A node represents a physical or virtual Thymio
 */
export interface INode extends IBasicNode {
    /**
     * Group to which this robot belongs
     *
     */
    readonly group: Group;
    readonly type: NodeType;
    /**
     * Status of the robot
     */
    readonly status: NodeStatus;
    /**
     * Name of the robot
     */
    readonly name: string;
    /**
     * A string representaion of the type of the robot
     * see [[type]]
     */
    readonly statusAsString: string;
    /**
     * A string representaion of the status of the robot
     * see [[type]]
     */
    readonly typeAsString: string;
    /**
     * Shorthand for status == NodeStatus.Ready,
     * see [[type]]
     */
    readonly isReady: boolean;
    /**
     * Known events
     *
     * @see [[IGroup.variable]]
     */
    readonly sharedVariables: Variables;
    /**
     * Known events
     *
     * @see [[IGroup.eventsDescriptions]]
     */
    readonly eventsDescriptions: EventDescription[];
    /**
     * @event
     */
    onVmExecutionStateChanged: (...args: any) => void;
    /**
     * Emitted when the status of the robot changes
     * @event
     */
    onStatusChanged: (newStatus: NodeStatus) => void;
    /**
     * Emitted when the name of the robot changes
     * @see [[rename]], [[name]]
     * @event
     */
    onNameChanged: (newName: string) => void;
    /**
     * Notify when one or several events are emmited
     * by the robot.
     *
     * @event
     */
    onEvents: (events: Events) => void;
    /**
     * Notify changes in the event table of the group associated to this
     * robot
     *
     * @event
     * @see [[IGroup.onEventsDescriptionsChanged]]
     */
    onEventsDescriptionsChanged: (events: EventDescription[]) => void;
    /**
     * Notify of shared variables changes in the group associated to that
     * robot
     *
     * @event
     * @see [[IGroup.onVariablesChanged]]
     */
    onSharedVariablesChanged: (sharedVariables: Variables) => void;
    /**
     * Notifiy of robot variables changes.
     * These are both the variables of the robot and the variables defined
     * in the currently executing programm.
     * @event
     */
    onVariablesChanged: (variables: Variables) => void;
    /**
     * Notifiy of scratchpad changes.
     * @event
     */
    onScratchpadChanged: (text: string, language: mobsya.fb.ProgrammingLanguage) => void;
    /**
     * Emitted when the robot is associated to another group
     * When a group change happens, it is the responsability of
     * the application to rewire the group-monitoring callbacks
     * such as [[onSharedVariablesChanged]] and [[onEventsDescriptionsChanged]].
     *
     * [[watchSharedVariablesAndEvents]] may also need to be reconfigured after a group
     * change.
     *
     * @event
     */
    onGroupChanged: (group: Group) => void;
    /** Lock the device
    *  Locking a device is akin to take sole ownership of it until the connection
    *  is closed or the unlock method is explicitely called
    *
    *  The device must be in the available state before it can be locked.
    *  Once a device is locked, all client will see the device becoming busy.
    *
    *  If the device can not be locked, an [[mobsya.fb.Error]] is raised.
    *
    * @throws [[mobsya.fb.Error]]
    */
    lock(): Promise<any>;
    /** Unlock the device
     * Once a device is unlocked, all client will see the device becoming available.
     * Once unlock, a device can't be written to until loc
     * @throws [[mobsya.fb.Error]]
     *
     * @see [[lock]]
     */
    unlock(): Promise<any>;
    /**
     * Send a request to rename a node
     * @throws [[mobsya.fb.Error]]
     *
     */
    rename(newName: string): Promise<any>;
    /** Get the description from the device
     *  The device must be in the available state before requesting the VM.
     *
     * @throws [[mobsya.fb.Error]]
     *
     * @see [[lock]]
     */
    asebaVMDescription(): Promise<any>;
    /** Load an aseba program on the VM
     * The device must be locked & ready before calling this function
     * The code is not directly executed. instead, {runProgram} must be call to start the execution
     * @param code - the aseba code to load
     *
     * @throws [[mobsya.fb.Error]]
     *
     * @see [[lock]]
     */
    sendAsebaProgram(code: string): Promise<any>;
    /** Run the code currently loaded on the vm
     * The device must be locked & ready before calling this function
     *
     * @throws [[mobsya.fb.Error]]
     * @see [[lock]]
     */
    runProgram(): Promise<any>;
    /** Flash the code currently loaded on the vm to the flash memory
     * The device must be locked & ready before calling this function
     *
     * @throws [[mobsya.fb.Error]]
     * @see [[lock]]
     */
    flashProgram(): Promise<any>;
    /**
     * Set the values of the specified variables.
     * Unlike [[setSharedVariables]], existing variables
     * not modifieed by this function are left unmodified
     *
     * @param variables the variables to modify
     */
    setVariables(variables: Variables): Promise<any>;
    /**
     * Set the shared variables on the group associated with this robot
     *
     * Overwrite all existing shared variables
     * the node must be locked.
     *
     * @see [[lock]]
     *
     */
    setSharedVariables(variables: Variables): Promise<any>;
    /**
    * Set the event descriptions on the group associated with this robot
    *
    * Overwrite all existing events descriptions
    * the node must be locked.
    *
    * @see [[lock]]
    *
    */
    setEventsDescriptions(events: EventDescription[]): Promise<any>;
    /**
     * Set the content of the scratchpad associated with this node
     *
     * The scratchpad is shared accross applications and persistent
     * across reconnections.
     */
    setScratchPad(text: string, language: mobsya.fb.ProgrammingLanguage): Promise<any>;
}
/**
 * @private
 */
export declare class Node extends BasicNode implements INode {
    Status: typeof NodeStatus;
    VMExecutionState: typeof VMExecutionState;
    Type: typeof NodeType;
    private _status;
    private _type;
    private _desc;
    _name: string;
    private _on_vars_changed_cb;
    private _on_events_cb;
    private _group;
    onGroupChanged: (group: Group) => void;
    onVmExecutionStateChanged: (...args: any) => void;
    onStatusChanged: (newStatus: NodeStatus) => void;
    onNameChanged: (newStatus: string) => void;
    onScratchpadChanged: (text: string, language: mobsya.fb.ProgrammingLanguage) => void;
    constructor(client: Client, id: NodeId, status: NodeStatus, type: NodeType);
    readonly group: Group;
    /** return the node type*/
    readonly type: NodeType;
    /** The node status
     *  @type {mobsya.fb.NodeStatus}
     */
    readonly status: NodeStatus;
    /** The node name
     *  @type {mobsya.fb.NodeStatus}
     */
    readonly name: string;
    rename(new_name: string): Promise<any>;
    /** Whether the node is ready (connected, and locked)
     *  @type {boolean}
     */
    readonly isReady: boolean;
    /** The node status converted to string.
     *  @type {string}
     */
    readonly statusAsString: "unknown" | "connected" | "disconnected" | "ready" | "available" | "busy";
    /** The node type converted to string.
     *  @type {string}
     */
    readonly typeAsString: "unknown" | "Thymio 2" | "Thymio Wireless" | "Simulated Thymio 2" | "Dummy Node";
    lock(): Promise<any>;
    unlock(): Promise<any>;
    asebaVMDescription(): Promise<any>;
    readonly sharedVariables: any;
    readonly eventsDescriptions: any;
    sendAsebaProgram(code: string): Promise<any>;
    /** Load an aesl program on the VM
     *  The device must be locked & ready before calling this function
     *  @param {external:String} code - the aseba code to load
     *  @throws {mobsya.fb.Error}
     *  @see lock
     */
    send_aesl_program(code: any): Promise<any>;
    runProgram(): Promise<any>;
    flashProgram(): Promise<any>;
    setVariables(map: any): Promise<any>;
    setSharedVariables(variables: any): Promise<any>;
    setEventsDescriptions(events: any): Promise<any>;
    setScratchPad(text: any, language: any): Promise<any>;
    onVariablesChanged: (variables: Map<string, any>) => void;
    onEvents: (events: Map<string, any>) => void;
    onEventsDescriptionsChanged: (events: EventDescription[]) => void;
    onSharedVariablesChanged: (variables: Map<string, any>) => void;
    _set_status(status: NodeStatus): void;
    _set_name(name: string): void;
    _set_group(group: Group): void;
}
/**
 *  This interface represents the connection with a remote
 *  Thymio Device Manager or Thymio 3
 *
 *  Once the connection established nodes connections and
 *  modification events will be broadcast through
 *  onNodesChanged.
 *
 *  When the connection is first establised,
 *  onNodesChanged will be called with the list of all known
 *  nodes.
 *
 * @see  [[createClient]]
 *
 *
 */
export interface IClient {
    /**
     * List of connected nodes
     */
    readonly nodes: INode[];
    /**
     * @param nodes Nodes whose status has changed
     * @event
     */
    onNodesChanged: (nodes: INode[]) => void;
    /**
     * Fired when the websocket is closed
     * @param event
     * @event
     */
    onClose: (event: CloseEvent) => void;
}
/**
 * @private
 */
declare class Client implements IClient {
    private _requests;
    private _nodes;
    private _flex;
    private _socket;
    onNodesChanged: (nodes: Node[]) => void;
    onClose: (event: CloseEvent) => void;
    /**
     *  @param {external:String} url : Web socket address
     *  @see lock
     */
    constructor(url: string);
    readonly nodes: Node[];
    private _onopen;
    private _onclose;
    private _onmessage;
    _request_aseba_vm_description(id: NodeId): Promise<any>;
    _send_program(id: NodeId, code: string, language: mobsya.fb.ProgrammingLanguage): Promise<any>;
    _set_vm_execution_state(id: NodeId, command: mobsya.fb.VMExecutionStateCommand): Promise<any>;
    _set_variables(id: NodeId, variables: Variables): Promise<any>;
    private _serialize_variables;
    private _serialize_variable;
    _emit_events(id: NodeId, variables: Variables): Promise<any>;
    _set_events_descriptions(id: NodeId, events: EventDescription[]): Promise<any>;
    private _serialize_events_descriptions;
    private _serialize_event_description;
    _set_scratchpad(id: NodeId, text: string, language: mobsya.fb.ProgrammingLanguage): Promise<any>;
    _lock_node(id: NodeId): Promise<any>;
    _unlock_node(id: NodeId): Promise<any>;
    _rename_node(id: NodeId, name: string): Promise<any>;
    _watch(id: NodeId, monitoring_flags: number): Promise<any>;
    private _nodes_changed_as_node_list;
    _nodes_from_id(id: NodeId): Node[];
    _group_from_id(id: NodeId): Group;
    private _id;
    private _unserialize_aseba_vm_description;
    private _create_node_id;
    private _wrap_message_and_send;
    private _gen_request_id;
    private _get_request;
    private _prepare_request;
}
/**
 * Connects to a Thymio Device Manager or a Thymio 3
 *
 * This Function is the main entry point of the API
 *
 * @param url WebSocket server to connect to.
 * The of the url is `ws://<server>:<port>`
 * This url need to be obtained by an implementation-defined manner.
 *
 * The server must be a Thymio Device Manger or a Thymio 3
 * Or otherwise implement the Thymio Device Manager protocol
 */
export declare function createClient(url: string): IClient;
export {};
